//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/zhangwen/Documents/zwdir/sync/workspace/howtobuildapp/j2objclibios/javasrc/com/google/gson/stream/JsonReader.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "JsonReader.h"
#include "JsonReaderInternalAccess.h"
#include "JsonScope.h"
#include "JsonToken.h"
#include "JsonTreeReader.h"
#include "MalformedJsonException.h"
#include "java/io/EOFException.h"
#include "java/io/IOException.h"
#include "java/io/Reader.h"
#include "java/lang/AssertionError.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/Math.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/util/Arrays.h"

@interface GSONJsonReader () {
 @public
  /*!
   @brief The input JSON.
   */
  JavaIoReader *in_;
  /*!
   @brief True to accept non-spec compliant JSON
   */
  jboolean lenient_;
  /*!
   @brief Use a manual buffer to easily read and unread upcoming characters, and
  also so we can create strings without an intermediate StringBuilder.
   We decode literals directly out of this buffer, so it must be at least as
  long as the longest token that can be reported as a number.
   */
  IOSCharArray *buffer_;
  jint pos_;
  jint limit_;
  jint lineNumber_;
  jint lineStart_;
  /*!
   @brief A peeked value that was composed entirely of digits with an optional
  leading dash.Positive values may not have a leading 0.
   */
  jlong peekedLong_;
  /*!
   @brief The number of characters in a peeked number literal.Increment 'pos' by
  this after reading a number.
   */
  jint peekedNumberLength_;
  /*!
   @brief A peeked string that should be parsed on the next double, long or string.
   This is populated before a numeric value is parsed and used if that parsing
  fails.
   */
  NSString *peekedString_;
  IOSIntArray *stack_;
  jint stackSize_;
  IOSObjectArray *pathNames_;
  IOSIntArray *pathIndices_;
}

- (jint)peekKeyword;

- (jint)peekNumber;

- (jboolean)isLiteralWithChar:(jchar)c;

/*!
 @brief Returns the string up to but not including <code>quote</code>, unescaping any
  character escape sequences encountered along the way.The opening quote
  should have already been read.
 This consumes the closing quote, but does
  not include it in the returned string.
 @param quote either ' or ".
 @throw NumberFormatExceptionif any unicode escape sequences are
      malformed.
 */
- (NSString *)nextQuotedValueWithChar:(jchar)quote;

/*!
 @brief Returns an unquoted value as a string.
 */
- (NSString *)nextUnquotedValue;

- (void)skipQuotedValueWithChar:(jchar)quote;

- (void)skipUnquotedValue;

- (void)pushWithInt:(jint)newTop;

/*!
 @brief Returns true once <code>limit - pos >= minimum</code>.If the data is
  exhausted before that many characters are available, this returns
  false.
 */
- (jboolean)fillBufferWithInt:(jint)minimum;

/*!
 @brief Returns the next character in the stream that is neither whitespace nor a
  part of a comment.When this returns, the returned character is always at 
 <code>buffer[pos-1]</code>; this means the caller can always push back the
  returned character by decrementing <code>pos</code>.
 */
- (jint)nextNonWhitespaceWithBoolean:(jboolean)throwOnEof;

- (void)checkLenient;

/*!
 @brief Advances the position until after the next newline character.If the line
  is terminated by "\r\n", the '\n' must be consumed as whitespace by the
  caller.
 */
- (void)skipToEndOfLine;

/*!
 @param toFind a string to search for. Must not contain a newline.
 */
- (jboolean)skipToWithNSString:(NSString *)toFind;

/*!
 @brief Unescapes the character identified by the character or characters that
  immediately follow a backslash.The backslash '\' should have already
  been read.
 This supports both unicode escapes "u000A" and two-character
  escapes "\n".
 @throw NumberFormatExceptionif any unicode escape sequences are
      malformed.
 */
- (jchar)readEscapeCharacter;

/*!
 @brief Throws a new IO exception with the given message and a context snippet
  with this reader's content.
 */
- (JavaIoIOException *)syntaxErrorWithNSString:(NSString *)message;

/*!
 @brief Consumes the non-execute prefix if it exists.
 */
- (void)consumeNonExecutePrefix;

@end

J2OBJC_FIELD_SETTER(GSONJsonReader, in_, JavaIoReader *)
J2OBJC_FIELD_SETTER(GSONJsonReader, buffer_, IOSCharArray *)
J2OBJC_FIELD_SETTER(GSONJsonReader, peekedString_, NSString *)
J2OBJC_FIELD_SETTER(GSONJsonReader, stack_, IOSIntArray *)
J2OBJC_FIELD_SETTER(GSONJsonReader, pathNames_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GSONJsonReader, pathIndices_, IOSIntArray *)

/*!
 @brief The only non-execute prefix this parser permits
 */
inline IOSCharArray *GSONJsonReader_get_NON_EXECUTE_PREFIX();
static IOSCharArray *GSONJsonReader_NON_EXECUTE_PREFIX;
J2OBJC_STATIC_FIELD_OBJ_FINAL(GSONJsonReader, NON_EXECUTE_PREFIX, IOSCharArray *)

inline jlong GSONJsonReader_get_MIN_INCOMPLETE_INTEGER();
#define GSONJsonReader_MIN_INCOMPLETE_INTEGER -922337203685477580LL
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, MIN_INCOMPLETE_INTEGER, jlong)

inline jint GSONJsonReader_get_PEEKED_NONE();
#define GSONJsonReader_PEEKED_NONE 0
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_NONE, jint)

inline jint GSONJsonReader_get_PEEKED_BEGIN_OBJECT();
#define GSONJsonReader_PEEKED_BEGIN_OBJECT 1
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_BEGIN_OBJECT, jint)

inline jint GSONJsonReader_get_PEEKED_END_OBJECT();
#define GSONJsonReader_PEEKED_END_OBJECT 2
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_END_OBJECT, jint)

inline jint GSONJsonReader_get_PEEKED_BEGIN_ARRAY();
#define GSONJsonReader_PEEKED_BEGIN_ARRAY 3
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_BEGIN_ARRAY, jint)

inline jint GSONJsonReader_get_PEEKED_END_ARRAY();
#define GSONJsonReader_PEEKED_END_ARRAY 4
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_END_ARRAY, jint)

inline jint GSONJsonReader_get_PEEKED_TRUE();
#define GSONJsonReader_PEEKED_TRUE 5
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_TRUE, jint)

inline jint GSONJsonReader_get_PEEKED_FALSE();
#define GSONJsonReader_PEEKED_FALSE 6
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_FALSE, jint)

inline jint GSONJsonReader_get_PEEKED_NULL();
#define GSONJsonReader_PEEKED_NULL 7
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_NULL, jint)

inline jint GSONJsonReader_get_PEEKED_SINGLE_QUOTED();
#define GSONJsonReader_PEEKED_SINGLE_QUOTED 8
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_SINGLE_QUOTED, jint)

inline jint GSONJsonReader_get_PEEKED_DOUBLE_QUOTED();
#define GSONJsonReader_PEEKED_DOUBLE_QUOTED 9
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_DOUBLE_QUOTED, jint)

inline jint GSONJsonReader_get_PEEKED_UNQUOTED();
#define GSONJsonReader_PEEKED_UNQUOTED 10
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_UNQUOTED, jint)

/*!
 @brief When this is returned, the string value is stored in peekedString.
 */
inline jint GSONJsonReader_get_PEEKED_BUFFERED();
#define GSONJsonReader_PEEKED_BUFFERED 11
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_BUFFERED, jint)

inline jint GSONJsonReader_get_PEEKED_SINGLE_QUOTED_NAME();
#define GSONJsonReader_PEEKED_SINGLE_QUOTED_NAME 12
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_SINGLE_QUOTED_NAME, jint)

inline jint GSONJsonReader_get_PEEKED_DOUBLE_QUOTED_NAME();
#define GSONJsonReader_PEEKED_DOUBLE_QUOTED_NAME 13
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_DOUBLE_QUOTED_NAME, jint)

inline jint GSONJsonReader_get_PEEKED_UNQUOTED_NAME();
#define GSONJsonReader_PEEKED_UNQUOTED_NAME 14
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_UNQUOTED_NAME, jint)

/*!
 @brief When this is returned, the integer value is stored in peekedLong.
 */
inline jint GSONJsonReader_get_PEEKED_LONG();
#define GSONJsonReader_PEEKED_LONG 15
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_LONG, jint)

inline jint GSONJsonReader_get_PEEKED_NUMBER();
#define GSONJsonReader_PEEKED_NUMBER 16
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_NUMBER, jint)

inline jint GSONJsonReader_get_PEEKED_EOF();
#define GSONJsonReader_PEEKED_EOF 17
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, PEEKED_EOF, jint)

inline jint GSONJsonReader_get_NUMBER_CHAR_NONE();
#define GSONJsonReader_NUMBER_CHAR_NONE 0
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, NUMBER_CHAR_NONE, jint)

inline jint GSONJsonReader_get_NUMBER_CHAR_SIGN();
#define GSONJsonReader_NUMBER_CHAR_SIGN 1
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, NUMBER_CHAR_SIGN, jint)

inline jint GSONJsonReader_get_NUMBER_CHAR_DIGIT();
#define GSONJsonReader_NUMBER_CHAR_DIGIT 2
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, NUMBER_CHAR_DIGIT, jint)

inline jint GSONJsonReader_get_NUMBER_CHAR_DECIMAL();
#define GSONJsonReader_NUMBER_CHAR_DECIMAL 3
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, NUMBER_CHAR_DECIMAL, jint)

inline jint GSONJsonReader_get_NUMBER_CHAR_FRACTION_DIGIT();
#define GSONJsonReader_NUMBER_CHAR_FRACTION_DIGIT 4
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, NUMBER_CHAR_FRACTION_DIGIT, jint)

inline jint GSONJsonReader_get_NUMBER_CHAR_EXP_E();
#define GSONJsonReader_NUMBER_CHAR_EXP_E 5
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, NUMBER_CHAR_EXP_E, jint)

inline jint GSONJsonReader_get_NUMBER_CHAR_EXP_SIGN();
#define GSONJsonReader_NUMBER_CHAR_EXP_SIGN 6
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, NUMBER_CHAR_EXP_SIGN, jint)

inline jint GSONJsonReader_get_NUMBER_CHAR_EXP_DIGIT();
#define GSONJsonReader_NUMBER_CHAR_EXP_DIGIT 7
J2OBJC_STATIC_FIELD_CONSTANT(GSONJsonReader, NUMBER_CHAR_EXP_DIGIT, jint)

__attribute__((unused)) static jint GSONJsonReader_peekKeyword(GSONJsonReader *self);

__attribute__((unused)) static jint GSONJsonReader_peekNumber(GSONJsonReader *self);

__attribute__((unused)) static jboolean GSONJsonReader_isLiteralWithChar_(GSONJsonReader *self, jchar c);

__attribute__((unused)) static NSString *GSONJsonReader_nextQuotedValueWithChar_(GSONJsonReader *self, jchar quote);

__attribute__((unused)) static NSString *GSONJsonReader_nextUnquotedValue(GSONJsonReader *self);

__attribute__((unused)) static void GSONJsonReader_skipQuotedValueWithChar_(GSONJsonReader *self, jchar quote);

__attribute__((unused)) static void GSONJsonReader_skipUnquotedValue(GSONJsonReader *self);

__attribute__((unused)) static void GSONJsonReader_pushWithInt_(GSONJsonReader *self, jint newTop);

__attribute__((unused)) static jboolean GSONJsonReader_fillBufferWithInt_(GSONJsonReader *self, jint minimum);

__attribute__((unused)) static jint GSONJsonReader_nextNonWhitespaceWithBoolean_(GSONJsonReader *self, jboolean throwOnEof);

__attribute__((unused)) static void GSONJsonReader_checkLenient(GSONJsonReader *self);

__attribute__((unused)) static void GSONJsonReader_skipToEndOfLine(GSONJsonReader *self);

__attribute__((unused)) static jboolean GSONJsonReader_skipToWithNSString_(GSONJsonReader *self, NSString *toFind);

__attribute__((unused)) static jchar GSONJsonReader_readEscapeCharacter(GSONJsonReader *self);

__attribute__((unused)) static JavaIoIOException *GSONJsonReader_syntaxErrorWithNSString_(GSONJsonReader *self, NSString *message);

__attribute__((unused)) static void GSONJsonReader_consumeNonExecutePrefix(GSONJsonReader *self);

@interface GSONJsonReader_1 : GSONJsonReaderInternalAccess

- (instancetype)init;

- (void)promoteNameToValueWithGSONJsonReader:(GSONJsonReader *)reader;

@end

J2OBJC_EMPTY_STATIC_INIT(GSONJsonReader_1)

__attribute__((unused)) static void GSONJsonReader_1_init(GSONJsonReader_1 *self);

__attribute__((unused)) static GSONJsonReader_1 *new_GSONJsonReader_1_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static GSONJsonReader_1 *create_GSONJsonReader_1_init();

J2OBJC_INITIALIZED_DEFN(GSONJsonReader)

@implementation GSONJsonReader

- (instancetype)initWithJavaIoReader:(JavaIoReader *)inArg {
  GSONJsonReader_initWithJavaIoReader_(self, inArg);
  return self;
}

- (void)setLenientWithBoolean:(jboolean)lenient {
  self->lenient_ = lenient;
}

- (jboolean)isLenient {
  return lenient_;
}

- (void)beginArray {
  jint p = peeked_;
  if (p == GSONJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GSONJsonReader_PEEKED_BEGIN_ARRAY) {
    GSONJsonReader_pushWithInt_(self, GSONJsonScope_EMPTY_ARRAY);
    *IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1) = 0;
    peeked_ = GSONJsonReader_PEEKED_NONE;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected BEGIN_ARRAY but was ", [self peek], [self locationString]));
  }
}

- (void)endArray {
  jint p = peeked_;
  if (p == GSONJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GSONJsonReader_PEEKED_END_ARRAY) {
    stackSize_--;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    peeked_ = GSONJsonReader_PEEKED_NONE;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected END_ARRAY but was ", [self peek], [self locationString]));
  }
}

- (void)beginObject {
  jint p = peeked_;
  if (p == GSONJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GSONJsonReader_PEEKED_BEGIN_OBJECT) {
    GSONJsonReader_pushWithInt_(self, GSONJsonScope_EMPTY_OBJECT);
    peeked_ = GSONJsonReader_PEEKED_NONE;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected BEGIN_OBJECT but was ", [self peek], [self locationString]));
  }
}

- (void)endObject {
  jint p = peeked_;
  if (p == GSONJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GSONJsonReader_PEEKED_END_OBJECT) {
    stackSize_--;
    (void) IOSObjectArray_Set(nil_chk(pathNames_), stackSize_, nil);
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    peeked_ = GSONJsonReader_PEEKED_NONE;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected END_OBJECT but was ", [self peek], [self locationString]));
  }
}

- (jboolean)hasNext {
  jint p = peeked_;
  if (p == GSONJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  return p != GSONJsonReader_PEEKED_END_OBJECT && p != GSONJsonReader_PEEKED_END_ARRAY;
}

- (GSONJsonToken *)peek {
  jint p = peeked_;
  if (p == GSONJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  switch (p) {
    case GSONJsonReader_PEEKED_BEGIN_OBJECT:
    return JreLoadEnum(GSONJsonToken, BEGIN_OBJECT);
    case GSONJsonReader_PEEKED_END_OBJECT:
    return JreLoadEnum(GSONJsonToken, END_OBJECT);
    case GSONJsonReader_PEEKED_BEGIN_ARRAY:
    return JreLoadEnum(GSONJsonToken, BEGIN_ARRAY);
    case GSONJsonReader_PEEKED_END_ARRAY:
    return JreLoadEnum(GSONJsonToken, END_ARRAY);
    case GSONJsonReader_PEEKED_SINGLE_QUOTED_NAME:
    case GSONJsonReader_PEEKED_DOUBLE_QUOTED_NAME:
    case GSONJsonReader_PEEKED_UNQUOTED_NAME:
    return JreLoadEnum(GSONJsonToken, NAME);
    case GSONJsonReader_PEEKED_TRUE:
    case GSONJsonReader_PEEKED_FALSE:
    return JreLoadEnum(GSONJsonToken, BOOLEAN);
    case GSONJsonReader_PEEKED_NULL:
    return JreLoadEnum(GSONJsonToken, NULL);
    case GSONJsonReader_PEEKED_SINGLE_QUOTED:
    case GSONJsonReader_PEEKED_DOUBLE_QUOTED:
    case GSONJsonReader_PEEKED_UNQUOTED:
    case GSONJsonReader_PEEKED_BUFFERED:
    return JreLoadEnum(GSONJsonToken, STRING);
    case GSONJsonReader_PEEKED_LONG:
    case GSONJsonReader_PEEKED_NUMBER:
    return JreLoadEnum(GSONJsonToken, NUMBER);
    case GSONJsonReader_PEEKED_EOF:
    return JreLoadEnum(GSONJsonToken, END_DOCUMENT);
    default:
    @throw new_JavaLangAssertionError_init();
  }
}

- (jint)doPeek {
  jint peekStack = IOSIntArray_Get(nil_chk(stack_), stackSize_ - 1);
  if (peekStack == GSONJsonScope_EMPTY_ARRAY) {
    *IOSIntArray_GetRef(stack_, stackSize_ - 1) = GSONJsonScope_NONEMPTY_ARRAY;
  }
  else if (peekStack == GSONJsonScope_NONEMPTY_ARRAY) {
    jint c = GSONJsonReader_nextNonWhitespaceWithBoolean_(self, true);
    switch (c) {
      case ']':
      return peeked_ = GSONJsonReader_PEEKED_END_ARRAY;
      case ';':
      GSONJsonReader_checkLenient(self);
      case ',':
      break;
      default:
      @throw nil_chk(GSONJsonReader_syntaxErrorWithNSString_(self, @"Unterminated array"));
    }
  }
  else if (peekStack == GSONJsonScope_EMPTY_OBJECT || peekStack == GSONJsonScope_NONEMPTY_OBJECT) {
    *IOSIntArray_GetRef(stack_, stackSize_ - 1) = GSONJsonScope_DANGLING_NAME;
    if (peekStack == GSONJsonScope_NONEMPTY_OBJECT) {
      jint c = GSONJsonReader_nextNonWhitespaceWithBoolean_(self, true);
      switch (c) {
        case '}':
        return peeked_ = GSONJsonReader_PEEKED_END_OBJECT;
        case ';':
        GSONJsonReader_checkLenient(self);
        case ',':
        break;
        default:
        @throw nil_chk(GSONJsonReader_syntaxErrorWithNSString_(self, @"Unterminated object"));
      }
    }
    jint c = GSONJsonReader_nextNonWhitespaceWithBoolean_(self, true);
    switch (c) {
      case '"':
      return peeked_ = GSONJsonReader_PEEKED_DOUBLE_QUOTED_NAME;
      case '\'':
      GSONJsonReader_checkLenient(self);
      return peeked_ = GSONJsonReader_PEEKED_SINGLE_QUOTED_NAME;
      case '}':
      if (peekStack != GSONJsonScope_NONEMPTY_OBJECT) {
        return peeked_ = GSONJsonReader_PEEKED_END_OBJECT;
      }
      else {
        @throw nil_chk(GSONJsonReader_syntaxErrorWithNSString_(self, @"Expected name"));
      }
      default:
      GSONJsonReader_checkLenient(self);
      pos_--;
      if (GSONJsonReader_isLiteralWithChar_(self, (jchar) c)) {
        return peeked_ = GSONJsonReader_PEEKED_UNQUOTED_NAME;
      }
      else {
        @throw nil_chk(GSONJsonReader_syntaxErrorWithNSString_(self, @"Expected name"));
      }
    }
  }
  else if (peekStack == GSONJsonScope_DANGLING_NAME) {
    *IOSIntArray_GetRef(stack_, stackSize_ - 1) = GSONJsonScope_NONEMPTY_OBJECT;
    jint c = GSONJsonReader_nextNonWhitespaceWithBoolean_(self, true);
    switch (c) {
      case ':':
      break;
      case '=':
      GSONJsonReader_checkLenient(self);
      if ((pos_ < limit_ || GSONJsonReader_fillBufferWithInt_(self, 1)) && IOSCharArray_Get(nil_chk(buffer_), pos_) == '>') {
        pos_++;
      }
      break;
      default:
      @throw nil_chk(GSONJsonReader_syntaxErrorWithNSString_(self, @"Expected ':'"));
    }
  }
  else if (peekStack == GSONJsonScope_EMPTY_DOCUMENT) {
    if (lenient_) {
      GSONJsonReader_consumeNonExecutePrefix(self);
    }
    *IOSIntArray_GetRef(nil_chk(stack_), stackSize_ - 1) = GSONJsonScope_NONEMPTY_DOCUMENT;
  }
  else if (peekStack == GSONJsonScope_NONEMPTY_DOCUMENT) {
    jint c = GSONJsonReader_nextNonWhitespaceWithBoolean_(self, false);
    if (c == -1) {
      return peeked_ = GSONJsonReader_PEEKED_EOF;
    }
    else {
      GSONJsonReader_checkLenient(self);
      pos_--;
    }
  }
  else if (peekStack == GSONJsonScope_CLOSED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"JsonReader is closed");
  }
  jint c = GSONJsonReader_nextNonWhitespaceWithBoolean_(self, true);
  switch (c) {
    case ']':
    if (peekStack == GSONJsonScope_EMPTY_ARRAY) {
      return peeked_ = GSONJsonReader_PEEKED_END_ARRAY;
    }
    case ';':
    case ',':
    if (peekStack == GSONJsonScope_EMPTY_ARRAY || peekStack == GSONJsonScope_NONEMPTY_ARRAY) {
      GSONJsonReader_checkLenient(self);
      pos_--;
      return peeked_ = GSONJsonReader_PEEKED_NULL;
    }
    else {
      @throw nil_chk(GSONJsonReader_syntaxErrorWithNSString_(self, @"Unexpected value"));
    }
    case '\'':
    GSONJsonReader_checkLenient(self);
    return peeked_ = GSONJsonReader_PEEKED_SINGLE_QUOTED;
    case '"':
    return peeked_ = GSONJsonReader_PEEKED_DOUBLE_QUOTED;
    case '[':
    return peeked_ = GSONJsonReader_PEEKED_BEGIN_ARRAY;
    case '{':
    return peeked_ = GSONJsonReader_PEEKED_BEGIN_OBJECT;
    default:
    pos_--;
  }
  jint result = GSONJsonReader_peekKeyword(self);
  if (result != GSONJsonReader_PEEKED_NONE) {
    return result;
  }
  result = GSONJsonReader_peekNumber(self);
  if (result != GSONJsonReader_PEEKED_NONE) {
    return result;
  }
  if (!GSONJsonReader_isLiteralWithChar_(self, IOSCharArray_Get(nil_chk(buffer_), pos_))) {
    @throw nil_chk(GSONJsonReader_syntaxErrorWithNSString_(self, @"Expected value"));
  }
  GSONJsonReader_checkLenient(self);
  return peeked_ = GSONJsonReader_PEEKED_UNQUOTED;
}

- (jint)peekKeyword {
  return GSONJsonReader_peekKeyword(self);
}

- (jint)peekNumber {
  return GSONJsonReader_peekNumber(self);
}

- (jboolean)isLiteralWithChar:(jchar)c {
  return GSONJsonReader_isLiteralWithChar_(self, c);
}

- (NSString *)nextName {
  jint p = peeked_;
  if (p == GSONJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  NSString *result;
  if (p == GSONJsonReader_PEEKED_UNQUOTED_NAME) {
    result = GSONJsonReader_nextUnquotedValue(self);
  }
  else if (p == GSONJsonReader_PEEKED_SINGLE_QUOTED_NAME) {
    result = GSONJsonReader_nextQuotedValueWithChar_(self, '\'');
  }
  else if (p == GSONJsonReader_PEEKED_DOUBLE_QUOTED_NAME) {
    result = GSONJsonReader_nextQuotedValueWithChar_(self, '"');
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a name but was ", [self peek], [self locationString]));
  }
  peeked_ = GSONJsonReader_PEEKED_NONE;
  (void) IOSObjectArray_Set(nil_chk(pathNames_), stackSize_ - 1, result);
  return result;
}

- (NSString *)nextString {
  jint p = peeked_;
  if (p == GSONJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  NSString *result;
  if (p == GSONJsonReader_PEEKED_UNQUOTED) {
    result = GSONJsonReader_nextUnquotedValue(self);
  }
  else if (p == GSONJsonReader_PEEKED_SINGLE_QUOTED) {
    result = GSONJsonReader_nextQuotedValueWithChar_(self, '\'');
  }
  else if (p == GSONJsonReader_PEEKED_DOUBLE_QUOTED) {
    result = GSONJsonReader_nextQuotedValueWithChar_(self, '"');
  }
  else if (p == GSONJsonReader_PEEKED_BUFFERED) {
    result = peekedString_;
    peekedString_ = nil;
  }
  else if (p == GSONJsonReader_PEEKED_LONG) {
    result = JavaLangLong_toStringWithLong_(peekedLong_);
  }
  else if (p == GSONJsonReader_PEEKED_NUMBER) {
    result = [NSString java_stringWithCharacters:buffer_ offset:pos_ length:peekedNumberLength_];
    pos_ += peekedNumberLength_;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a string but was ", [self peek], [self locationString]));
  }
  peeked_ = GSONJsonReader_PEEKED_NONE;
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  return result;
}

- (jboolean)nextBoolean {
  jint p = peeked_;
  if (p == GSONJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GSONJsonReader_PEEKED_TRUE) {
    peeked_ = GSONJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return true;
  }
  else if (p == GSONJsonReader_PEEKED_FALSE) {
    peeked_ = GSONJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return false;
  }
  @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a boolean but was ", [self peek], [self locationString]));
}

- (void)nextNull {
  jint p = peeked_;
  if (p == GSONJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GSONJsonReader_PEEKED_NULL) {
    peeked_ = GSONJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected null but was ", [self peek], [self locationString]));
  }
}

- (jdouble)nextDouble {
  jint p = peeked_;
  if (p == GSONJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GSONJsonReader_PEEKED_LONG) {
    peeked_ = GSONJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return (jdouble) peekedLong_;
  }
  if (p == GSONJsonReader_PEEKED_NUMBER) {
    peekedString_ = [NSString java_stringWithCharacters:buffer_ offset:pos_ length:peekedNumberLength_];
    pos_ += peekedNumberLength_;
  }
  else if (p == GSONJsonReader_PEEKED_SINGLE_QUOTED || p == GSONJsonReader_PEEKED_DOUBLE_QUOTED) {
    peekedString_ = GSONJsonReader_nextQuotedValueWithChar_(self, p == GSONJsonReader_PEEKED_SINGLE_QUOTED ? '\'' : '"');
  }
  else if (p == GSONJsonReader_PEEKED_UNQUOTED) {
    peekedString_ = GSONJsonReader_nextUnquotedValue(self);
  }
  else if (p != GSONJsonReader_PEEKED_BUFFERED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a double but was ", [self peek], [self locationString]));
  }
  peeked_ = GSONJsonReader_PEEKED_BUFFERED;
  jdouble result = JavaLangDouble_parseDoubleWithNSString_(peekedString_);
  if (!lenient_ && (JavaLangDouble_isNaNWithDouble_(result) || JavaLangDouble_isInfiniteWithDouble_(result))) {
    @throw new_GSONMalformedJsonException_initWithNSString_(JreStrcat("$D$", @"JSON forbids NaN and infinities: ", result, [self locationString]));
  }
  peekedString_ = nil;
  peeked_ = GSONJsonReader_PEEKED_NONE;
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  return result;
}

- (jlong)nextLong {
  jint p = peeked_;
  if (p == GSONJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GSONJsonReader_PEEKED_LONG) {
    peeked_ = GSONJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return peekedLong_;
  }
  if (p == GSONJsonReader_PEEKED_NUMBER) {
    peekedString_ = [NSString java_stringWithCharacters:buffer_ offset:pos_ length:peekedNumberLength_];
    pos_ += peekedNumberLength_;
  }
  else if (p == GSONJsonReader_PEEKED_SINGLE_QUOTED || p == GSONJsonReader_PEEKED_DOUBLE_QUOTED || p == GSONJsonReader_PEEKED_UNQUOTED) {
    if (p == GSONJsonReader_PEEKED_UNQUOTED) {
      peekedString_ = GSONJsonReader_nextUnquotedValue(self);
    }
    else {
      peekedString_ = GSONJsonReader_nextQuotedValueWithChar_(self, p == GSONJsonReader_PEEKED_SINGLE_QUOTED ? '\'' : '"');
    }
    @try {
      jlong result = JavaLangLong_parseLongWithNSString_(peekedString_);
      peeked_ = GSONJsonReader_PEEKED_NONE;
      (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
      return result;
    }
    @catch (JavaLangNumberFormatException *ignored) {
    }
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a long but was ", [self peek], [self locationString]));
  }
  peeked_ = GSONJsonReader_PEEKED_BUFFERED;
  jdouble asDouble = JavaLangDouble_parseDoubleWithNSString_(peekedString_);
  jlong result = JreFpToLong(asDouble);
  if (result != asDouble) {
    @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$$$", @"Expected a long but was ", peekedString_, [self locationString]));
  }
  peekedString_ = nil;
  peeked_ = GSONJsonReader_PEEKED_NONE;
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  return result;
}

- (NSString *)nextQuotedValueWithChar:(jchar)quote {
  return GSONJsonReader_nextQuotedValueWithChar_(self, quote);
}

- (NSString *)nextUnquotedValue {
  return GSONJsonReader_nextUnquotedValue(self);
}

- (void)skipQuotedValueWithChar:(jchar)quote {
  GSONJsonReader_skipQuotedValueWithChar_(self, quote);
}

- (void)skipUnquotedValue {
  GSONJsonReader_skipUnquotedValue(self);
}

- (jint)nextInt {
  jint p = peeked_;
  if (p == GSONJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  jint result;
  if (p == GSONJsonReader_PEEKED_LONG) {
    result = (jint) peekedLong_;
    if (peekedLong_ != result) {
      @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$J$", @"Expected an int but was ", peekedLong_, [self locationString]));
    }
    peeked_ = GSONJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return result;
  }
  if (p == GSONJsonReader_PEEKED_NUMBER) {
    peekedString_ = [NSString java_stringWithCharacters:buffer_ offset:pos_ length:peekedNumberLength_];
    pos_ += peekedNumberLength_;
  }
  else if (p == GSONJsonReader_PEEKED_SINGLE_QUOTED || p == GSONJsonReader_PEEKED_DOUBLE_QUOTED || p == GSONJsonReader_PEEKED_UNQUOTED) {
    if (p == GSONJsonReader_PEEKED_UNQUOTED) {
      peekedString_ = GSONJsonReader_nextUnquotedValue(self);
    }
    else {
      peekedString_ = GSONJsonReader_nextQuotedValueWithChar_(self, p == GSONJsonReader_PEEKED_SINGLE_QUOTED ? '\'' : '"');
    }
    @try {
      result = JavaLangInteger_parseIntWithNSString_(peekedString_);
      peeked_ = GSONJsonReader_PEEKED_NONE;
      (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
      return result;
    }
    @catch (JavaLangNumberFormatException *ignored) {
    }
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected an int but was ", [self peek], [self locationString]));
  }
  peeked_ = GSONJsonReader_PEEKED_BUFFERED;
  jdouble asDouble = JavaLangDouble_parseDoubleWithNSString_(peekedString_);
  result = JreFpToInt(asDouble);
  if (result != asDouble) {
    @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$$$", @"Expected an int but was ", peekedString_, [self locationString]));
  }
  peekedString_ = nil;
  peeked_ = GSONJsonReader_PEEKED_NONE;
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  return result;
}

- (void)close {
  peeked_ = GSONJsonReader_PEEKED_NONE;
  *IOSIntArray_GetRef(nil_chk(stack_), 0) = GSONJsonScope_CLOSED;
  stackSize_ = 1;
  [((JavaIoReader *) nil_chk(in_)) close];
}

- (void)skipValue {
  jint count = 0;
  do {
    jint p = peeked_;
    if (p == GSONJsonReader_PEEKED_NONE) {
      p = [self doPeek];
    }
    if (p == GSONJsonReader_PEEKED_BEGIN_ARRAY) {
      GSONJsonReader_pushWithInt_(self, GSONJsonScope_EMPTY_ARRAY);
      count++;
    }
    else if (p == GSONJsonReader_PEEKED_BEGIN_OBJECT) {
      GSONJsonReader_pushWithInt_(self, GSONJsonScope_EMPTY_OBJECT);
      count++;
    }
    else if (p == GSONJsonReader_PEEKED_END_ARRAY) {
      stackSize_--;
      count--;
    }
    else if (p == GSONJsonReader_PEEKED_END_OBJECT) {
      stackSize_--;
      count--;
    }
    else if (p == GSONJsonReader_PEEKED_UNQUOTED_NAME || p == GSONJsonReader_PEEKED_UNQUOTED) {
      GSONJsonReader_skipUnquotedValue(self);
    }
    else if (p == GSONJsonReader_PEEKED_SINGLE_QUOTED || p == GSONJsonReader_PEEKED_SINGLE_QUOTED_NAME) {
      GSONJsonReader_skipQuotedValueWithChar_(self, '\'');
    }
    else if (p == GSONJsonReader_PEEKED_DOUBLE_QUOTED || p == GSONJsonReader_PEEKED_DOUBLE_QUOTED_NAME) {
      GSONJsonReader_skipQuotedValueWithChar_(self, '"');
    }
    else if (p == GSONJsonReader_PEEKED_NUMBER) {
      pos_ += peekedNumberLength_;
    }
    peeked_ = GSONJsonReader_PEEKED_NONE;
  }
  while (count != 0);
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  (void) IOSObjectArray_Set(nil_chk(pathNames_), stackSize_ - 1, @"null");
}

- (void)pushWithInt:(jint)newTop {
  GSONJsonReader_pushWithInt_(self, newTop);
}

- (jboolean)fillBufferWithInt:(jint)minimum {
  return GSONJsonReader_fillBufferWithInt_(self, minimum);
}

- (jint)nextNonWhitespaceWithBoolean:(jboolean)throwOnEof {
  return GSONJsonReader_nextNonWhitespaceWithBoolean_(self, throwOnEof);
}

- (void)checkLenient {
  GSONJsonReader_checkLenient(self);
}

- (void)skipToEndOfLine {
  GSONJsonReader_skipToEndOfLine(self);
}

- (jboolean)skipToWithNSString:(NSString *)toFind {
  return GSONJsonReader_skipToWithNSString_(self, toFind);
}

- (NSString *)description {
  return JreStrcat("$$", [[self java_getClass] getSimpleName], [self locationString]);
}

- (NSString *)locationString {
  jint line = lineNumber_ + 1;
  jint column = pos_ - lineStart_ + 1;
  return JreStrcat("$I$I$$", @" at line ", line, @" column ", column, @" path ", [self getPath]);
}

- (NSString *)getPath {
  JavaLangStringBuilder *result = [new_JavaLangStringBuilder_init() appendWithChar:'$'];
  for (jint i = 0, size = stackSize_; i < size; i++) {
    switch (IOSIntArray_Get(nil_chk(stack_), i)) {
      case GSONJsonScope_EMPTY_ARRAY:
      case GSONJsonScope_NONEMPTY_ARRAY:
      (void) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk(result)) appendWithChar:'['])) appendWithInt:IOSIntArray_Get(nil_chk(pathIndices_), i)])) appendWithChar:']'];
      break;
      case GSONJsonScope_EMPTY_OBJECT:
      case GSONJsonScope_DANGLING_NAME:
      case GSONJsonScope_NONEMPTY_OBJECT:
      (void) [((JavaLangStringBuilder *) nil_chk(result)) appendWithChar:'.'];
      if (IOSObjectArray_Get(nil_chk(pathNames_), i) != nil) {
        (void) [result appendWithNSString:IOSObjectArray_Get(pathNames_, i)];
      }
      break;
      case GSONJsonScope_NONEMPTY_DOCUMENT:
      case GSONJsonScope_EMPTY_DOCUMENT:
      case GSONJsonScope_CLOSED:
      break;
    }
  }
  return [((JavaLangStringBuilder *) nil_chk(result)) description];
}

- (jchar)readEscapeCharacter {
  return GSONJsonReader_readEscapeCharacter(self);
}

- (JavaIoIOException *)syntaxErrorWithNSString:(NSString *)message {
  return GSONJsonReader_syntaxErrorWithNSString_(self, message);
}

- (void)consumeNonExecutePrefix {
  GSONJsonReader_consumeNonExecutePrefix(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x11, 1, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x11, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LGSONJsonToken;", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "I", 0x0, -1, -1, 3, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x2, 4, 5, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "D", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x2, 6, 5, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x2, 7, 5, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x2, 8, 9, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 10, 9, 3, -1, -1, -1 },
    { NULL, "I", 0x2, 11, 2, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x2, 12, 13, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 14, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "C", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "LJavaIoIOException;", 0x2, 15, 13, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaIoReader:);
  methods[1].selector = @selector(setLenientWithBoolean:);
  methods[2].selector = @selector(isLenient);
  methods[3].selector = @selector(beginArray);
  methods[4].selector = @selector(endArray);
  methods[5].selector = @selector(beginObject);
  methods[6].selector = @selector(endObject);
  methods[7].selector = @selector(hasNext);
  methods[8].selector = @selector(peek);
  methods[9].selector = @selector(doPeek);
  methods[10].selector = @selector(peekKeyword);
  methods[11].selector = @selector(peekNumber);
  methods[12].selector = @selector(isLiteralWithChar:);
  methods[13].selector = @selector(nextName);
  methods[14].selector = @selector(nextString);
  methods[15].selector = @selector(nextBoolean);
  methods[16].selector = @selector(nextNull);
  methods[17].selector = @selector(nextDouble);
  methods[18].selector = @selector(nextLong);
  methods[19].selector = @selector(nextQuotedValueWithChar:);
  methods[20].selector = @selector(nextUnquotedValue);
  methods[21].selector = @selector(skipQuotedValueWithChar:);
  methods[22].selector = @selector(skipUnquotedValue);
  methods[23].selector = @selector(nextInt);
  methods[24].selector = @selector(close);
  methods[25].selector = @selector(skipValue);
  methods[26].selector = @selector(pushWithInt:);
  methods[27].selector = @selector(fillBufferWithInt:);
  methods[28].selector = @selector(nextNonWhitespaceWithBoolean:);
  methods[29].selector = @selector(checkLenient);
  methods[30].selector = @selector(skipToEndOfLine);
  methods[31].selector = @selector(skipToWithNSString:);
  methods[32].selector = @selector(description);
  methods[33].selector = @selector(locationString);
  methods[34].selector = @selector(getPath);
  methods[35].selector = @selector(readEscapeCharacter);
  methods[36].selector = @selector(syntaxErrorWithNSString:);
  methods[37].selector = @selector(consumeNonExecutePrefix);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "NON_EXECUTE_PREFIX", "[C", .constantValue.asLong = 0, 0x1a, -1, 16, -1, -1 },
    { "MIN_INCOMPLETE_INTEGER", "J", .constantValue.asLong = GSONJsonReader_MIN_INCOMPLETE_INTEGER, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_NONE", "I", .constantValue.asInt = GSONJsonReader_PEEKED_NONE, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_BEGIN_OBJECT", "I", .constantValue.asInt = GSONJsonReader_PEEKED_BEGIN_OBJECT, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_END_OBJECT", "I", .constantValue.asInt = GSONJsonReader_PEEKED_END_OBJECT, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_BEGIN_ARRAY", "I", .constantValue.asInt = GSONJsonReader_PEEKED_BEGIN_ARRAY, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_END_ARRAY", "I", .constantValue.asInt = GSONJsonReader_PEEKED_END_ARRAY, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_TRUE", "I", .constantValue.asInt = GSONJsonReader_PEEKED_TRUE, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_FALSE", "I", .constantValue.asInt = GSONJsonReader_PEEKED_FALSE, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_NULL", "I", .constantValue.asInt = GSONJsonReader_PEEKED_NULL, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_SINGLE_QUOTED", "I", .constantValue.asInt = GSONJsonReader_PEEKED_SINGLE_QUOTED, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_DOUBLE_QUOTED", "I", .constantValue.asInt = GSONJsonReader_PEEKED_DOUBLE_QUOTED, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_UNQUOTED", "I", .constantValue.asInt = GSONJsonReader_PEEKED_UNQUOTED, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_BUFFERED", "I", .constantValue.asInt = GSONJsonReader_PEEKED_BUFFERED, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_SINGLE_QUOTED_NAME", "I", .constantValue.asInt = GSONJsonReader_PEEKED_SINGLE_QUOTED_NAME, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_DOUBLE_QUOTED_NAME", "I", .constantValue.asInt = GSONJsonReader_PEEKED_DOUBLE_QUOTED_NAME, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_UNQUOTED_NAME", "I", .constantValue.asInt = GSONJsonReader_PEEKED_UNQUOTED_NAME, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_LONG", "I", .constantValue.asInt = GSONJsonReader_PEEKED_LONG, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_NUMBER", "I", .constantValue.asInt = GSONJsonReader_PEEKED_NUMBER, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_EOF", "I", .constantValue.asInt = GSONJsonReader_PEEKED_EOF, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_NONE", "I", .constantValue.asInt = GSONJsonReader_NUMBER_CHAR_NONE, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_SIGN", "I", .constantValue.asInt = GSONJsonReader_NUMBER_CHAR_SIGN, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_DIGIT", "I", .constantValue.asInt = GSONJsonReader_NUMBER_CHAR_DIGIT, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_DECIMAL", "I", .constantValue.asInt = GSONJsonReader_NUMBER_CHAR_DECIMAL, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_FRACTION_DIGIT", "I", .constantValue.asInt = GSONJsonReader_NUMBER_CHAR_FRACTION_DIGIT, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_EXP_E", "I", .constantValue.asInt = GSONJsonReader_NUMBER_CHAR_EXP_E, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_EXP_SIGN", "I", .constantValue.asInt = GSONJsonReader_NUMBER_CHAR_EXP_SIGN, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_EXP_DIGIT", "I", .constantValue.asInt = GSONJsonReader_NUMBER_CHAR_EXP_DIGIT, 0x1a, -1, -1, -1, -1 },
    { "in_", "LJavaIoReader;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "lenient_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "buffer_", "[C", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "pos_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "limit_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "lineNumber_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "lineStart_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "peeked_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "peekedLong_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "peekedNumberLength_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "peekedString_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "stack_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "stackSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "pathNames_", "[LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "pathIndices_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaIoReader;", "setLenient", "Z", "LJavaIoIOException;", "isLiteral", "C", "nextQuotedValue", "skipQuotedValue", "push", "I", "fillBuffer", "nextNonWhitespace", "skipTo", "LNSString;", "toString", "syntaxError", &GSONJsonReader_NON_EXECUTE_PREFIX };
  static const J2ObjcClassInfo _GSONJsonReader = { "JsonReader", "com.google.gson.stream", ptrTable, methods, fields, 7, 0x1, 38, 43, -1, -1, -1, -1, -1 };
  return &_GSONJsonReader;
}

+ (void)initialize {
  if (self == [GSONJsonReader class]) {
    GSONJsonReader_NON_EXECUTE_PREFIX = [@")]}'\n" java_toCharArray];
    {
      *JreLoadStaticRef(GSONJsonReaderInternalAccess, INSTANCE) = new_GSONJsonReader_1_init();
    }
    J2OBJC_SET_INITIALIZED(GSONJsonReader)
  }
}

@end

void GSONJsonReader_initWithJavaIoReader_(GSONJsonReader *self, JavaIoReader *inArg) {
  NSObject_init(self);
  self->lenient_ = false;
  self->buffer_ = [IOSCharArray newArrayWithLength:1024];
  self->pos_ = 0;
  self->limit_ = 0;
  self->lineNumber_ = 0;
  self->lineStart_ = 0;
  self->peeked_ = GSONJsonReader_PEEKED_NONE;
  self->stack_ = [IOSIntArray newArrayWithLength:32];
  self->stackSize_ = 0;
  {
    *IOSIntArray_GetRef(self->stack_, self->stackSize_++) = GSONJsonScope_EMPTY_DOCUMENT;
  }
  self->pathNames_ = [IOSObjectArray newArrayWithLength:32 type:NSString_class_()];
  self->pathIndices_ = [IOSIntArray newArrayWithLength:32];
  if (inArg == nil) {
    @throw new_JavaLangNullPointerException_initWithNSString_(@"in == null");
  }
  self->in_ = inArg;
}

GSONJsonReader *new_GSONJsonReader_initWithJavaIoReader_(JavaIoReader *inArg) {
  J2OBJC_NEW_IMPL(GSONJsonReader, initWithJavaIoReader_, inArg)
}

GSONJsonReader *create_GSONJsonReader_initWithJavaIoReader_(JavaIoReader *inArg) {
  J2OBJC_CREATE_IMPL(GSONJsonReader, initWithJavaIoReader_, inArg)
}

jint GSONJsonReader_peekKeyword(GSONJsonReader *self) {
  jchar c = IOSCharArray_Get(nil_chk(self->buffer_), self->pos_);
  NSString *keyword;
  NSString *keywordUpper;
  jint peeking;
  if (c == 't' || c == 'T') {
    keyword = @"true";
    keywordUpper = @"TRUE";
    peeking = GSONJsonReader_PEEKED_TRUE;
  }
  else if (c == 'f' || c == 'F') {
    keyword = @"false";
    keywordUpper = @"FALSE";
    peeking = GSONJsonReader_PEEKED_FALSE;
  }
  else if (c == 'n' || c == 'N') {
    keyword = @"null";
    keywordUpper = @"NULL";
    peeking = GSONJsonReader_PEEKED_NULL;
  }
  else {
    return GSONJsonReader_PEEKED_NONE;
  }
  jint length = [keyword java_length];
  for (jint i = 1; i < length; i++) {
    if (self->pos_ + i >= self->limit_ && !GSONJsonReader_fillBufferWithInt_(self, i + 1)) {
      return GSONJsonReader_PEEKED_NONE;
    }
    c = IOSCharArray_Get(self->buffer_, self->pos_ + i);
    if (c != [keyword charAtWithInt:i] && c != [keywordUpper charAtWithInt:i]) {
      return GSONJsonReader_PEEKED_NONE;
    }
  }
  if ((self->pos_ + length < self->limit_ || GSONJsonReader_fillBufferWithInt_(self, length + 1)) && GSONJsonReader_isLiteralWithChar_(self, IOSCharArray_Get(self->buffer_, self->pos_ + length))) {
    return GSONJsonReader_PEEKED_NONE;
  }
  self->pos_ += length;
  return self->peeked_ = peeking;
}

jint GSONJsonReader_peekNumber(GSONJsonReader *self) {
  IOSCharArray *buffer = self->buffer_;
  jint p = self->pos_;
  jint l = self->limit_;
  jlong value = 0;
  jboolean negative = false;
  jboolean fitsInLong = true;
  jint last = GSONJsonReader_NUMBER_CHAR_NONE;
  jint i = 0;
  for (; true; i++) {
    if (p + i == l) {
      if (i == ((IOSCharArray *) nil_chk(buffer))->size_) {
        return GSONJsonReader_PEEKED_NONE;
      }
      if (!GSONJsonReader_fillBufferWithInt_(self, i + 1)) {
        break;
      }
      p = self->pos_;
      l = self->limit_;
    }
    jchar c = IOSCharArray_Get(nil_chk(buffer), p + i);
    switch (c) {
      case '-':
      if (last == GSONJsonReader_NUMBER_CHAR_NONE) {
        negative = true;
        last = GSONJsonReader_NUMBER_CHAR_SIGN;
        continue;
      }
      else if (last == GSONJsonReader_NUMBER_CHAR_EXP_E) {
        last = GSONJsonReader_NUMBER_CHAR_EXP_SIGN;
        continue;
      }
      return GSONJsonReader_PEEKED_NONE;
      case '+':
      if (last == GSONJsonReader_NUMBER_CHAR_EXP_E) {
        last = GSONJsonReader_NUMBER_CHAR_EXP_SIGN;
        continue;
      }
      return GSONJsonReader_PEEKED_NONE;
      case 'e':
      case 'E':
      if (last == GSONJsonReader_NUMBER_CHAR_DIGIT || last == GSONJsonReader_NUMBER_CHAR_FRACTION_DIGIT) {
        last = GSONJsonReader_NUMBER_CHAR_EXP_E;
        continue;
      }
      return GSONJsonReader_PEEKED_NONE;
      case '.':
      if (last == GSONJsonReader_NUMBER_CHAR_DIGIT) {
        last = GSONJsonReader_NUMBER_CHAR_DECIMAL;
        continue;
      }
      return GSONJsonReader_PEEKED_NONE;
      default:
      if (c < '0' || c > '9') {
        if (!GSONJsonReader_isLiteralWithChar_(self, c)) {
          goto break_charactersOfNumber;
        }
        return GSONJsonReader_PEEKED_NONE;
      }
      if (last == GSONJsonReader_NUMBER_CHAR_SIGN || last == GSONJsonReader_NUMBER_CHAR_NONE) {
        value = -(c - '0');
        last = GSONJsonReader_NUMBER_CHAR_DIGIT;
      }
      else if (last == GSONJsonReader_NUMBER_CHAR_DIGIT) {
        if (value == 0) {
          return GSONJsonReader_PEEKED_NONE;
        }
        jlong newValue = value * 10 - (c - '0');
        fitsInLong &= (value > GSONJsonReader_MIN_INCOMPLETE_INTEGER || (value == GSONJsonReader_MIN_INCOMPLETE_INTEGER && newValue < value));
        value = newValue;
      }
      else if (last == GSONJsonReader_NUMBER_CHAR_DECIMAL) {
        last = GSONJsonReader_NUMBER_CHAR_FRACTION_DIGIT;
      }
      else if (last == GSONJsonReader_NUMBER_CHAR_EXP_E || last == GSONJsonReader_NUMBER_CHAR_EXP_SIGN) {
        last = GSONJsonReader_NUMBER_CHAR_EXP_DIGIT;
      }
    }
  }
  break_charactersOfNumber: ;
  if (last == GSONJsonReader_NUMBER_CHAR_DIGIT && fitsInLong && (value != JavaLangLong_MIN_VALUE || negative) && (value != 0 || false == negative)) {
    self->peekedLong_ = negative ? value : -value;
    self->pos_ += i;
    return self->peeked_ = GSONJsonReader_PEEKED_LONG;
  }
  else if (last == GSONJsonReader_NUMBER_CHAR_DIGIT || last == GSONJsonReader_NUMBER_CHAR_FRACTION_DIGIT || last == GSONJsonReader_NUMBER_CHAR_EXP_DIGIT) {
    self->peekedNumberLength_ = i;
    return self->peeked_ = GSONJsonReader_PEEKED_NUMBER;
  }
  else {
    return GSONJsonReader_PEEKED_NONE;
  }
}

jboolean GSONJsonReader_isLiteralWithChar_(GSONJsonReader *self, jchar c) {
  switch (c) {
    case '/':
    case '\\':
    case ';':
    case '#':
    case '=':
    GSONJsonReader_checkLenient(self);
    case '{':
    case '}':
    case '[':
    case ']':
    case ':':
    case ',':
    case ' ':
    case 0x0009:
    case 0x000c:
    case 0x000d:
    case 0x000a:
    return false;
    default:
    return true;
  }
}

NSString *GSONJsonReader_nextQuotedValueWithChar_(GSONJsonReader *self, jchar quote) {
  IOSCharArray *buffer = self->buffer_;
  JavaLangStringBuilder *builder = nil;
  while (true) {
    jint p = self->pos_;
    jint l = self->limit_;
    jint start = p;
    while (p < l) {
      jint c = IOSCharArray_Get(nil_chk(buffer), p++);
      if (c == quote) {
        self->pos_ = p;
        jint len = p - start - 1;
        if (builder == nil) {
          return [NSString java_stringWithCharacters:buffer offset:start length:len];
        }
        else {
          (void) [builder appendWithCharArray:buffer withInt:start withInt:len];
          return [builder description];
        }
      }
      else if (c == '\\') {
        self->pos_ = p;
        jint len = p - start - 1;
        if (builder == nil) {
          jint estimatedLength = (len + 1) * 2;
          builder = new_JavaLangStringBuilder_initWithInt_(JavaLangMath_maxWithInt_withInt_(estimatedLength, 16));
        }
        (void) [builder appendWithCharArray:buffer withInt:start withInt:len];
        (void) [builder appendWithChar:GSONJsonReader_readEscapeCharacter(self)];
        p = self->pos_;
        l = self->limit_;
        start = p;
      }
      else if (c == 0x000a) {
        self->lineNumber_++;
        self->lineStart_ = p;
      }
    }
    if (builder == nil) {
      jint estimatedLength = (p - start) * 2;
      builder = new_JavaLangStringBuilder_initWithInt_(JavaLangMath_maxWithInt_withInt_(estimatedLength, 16));
    }
    (void) [builder appendWithCharArray:buffer withInt:start withInt:p - start];
    self->pos_ = p;
    if (!GSONJsonReader_fillBufferWithInt_(self, 1)) {
      @throw nil_chk(GSONJsonReader_syntaxErrorWithNSString_(self, @"Unterminated string"));
    }
  }
}

NSString *GSONJsonReader_nextUnquotedValue(GSONJsonReader *self) {
  JavaLangStringBuilder *builder = nil;
  jint i = 0;
  while (true) {
    for (; self->pos_ + i < self->limit_; i++) {
      switch (IOSCharArray_Get(nil_chk(self->buffer_), self->pos_ + i)) {
        case '/':
        case '\\':
        case ';':
        case '#':
        case '=':
        GSONJsonReader_checkLenient(self);
        case '{':
        case '}':
        case '[':
        case ']':
        case ':':
        case ',':
        case ' ':
        case 0x0009:
        case 0x000c:
        case 0x000d:
        case 0x000a:
        goto break_findNonLiteralCharacter;
      }
    }
    if (i < ((IOSCharArray *) nil_chk(self->buffer_))->size_) {
      if (GSONJsonReader_fillBufferWithInt_(self, i + 1)) {
        continue;
      }
      else {
        break;
      }
    }
    if (builder == nil) {
      builder = new_JavaLangStringBuilder_initWithInt_(JavaLangMath_maxWithInt_withInt_(i, 16));
    }
    (void) [builder appendWithCharArray:self->buffer_ withInt:self->pos_ withInt:i];
    self->pos_ += i;
    i = 0;
    if (!GSONJsonReader_fillBufferWithInt_(self, 1)) {
      break;
    }
  }
  break_findNonLiteralCharacter: ;
  NSString *result = (nil == builder) ? [NSString java_stringWithCharacters:self->buffer_ offset:self->pos_ length:i] : [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk(builder)) appendWithCharArray:self->buffer_ withInt:self->pos_ withInt:i])) description];
  self->pos_ += i;
  return result;
}

void GSONJsonReader_skipQuotedValueWithChar_(GSONJsonReader *self, jchar quote) {
  IOSCharArray *buffer = self->buffer_;
  do {
    jint p = self->pos_;
    jint l = self->limit_;
    while (p < l) {
      jint c = IOSCharArray_Get(nil_chk(buffer), p++);
      if (c == quote) {
        self->pos_ = p;
        return;
      }
      else if (c == '\\') {
        self->pos_ = p;
        GSONJsonReader_readEscapeCharacter(self);
        p = self->pos_;
        l = self->limit_;
      }
      else if (c == 0x000a) {
        self->lineNumber_++;
        self->lineStart_ = p;
      }
    }
    self->pos_ = p;
  }
  while (GSONJsonReader_fillBufferWithInt_(self, 1));
  @throw nil_chk(GSONJsonReader_syntaxErrorWithNSString_(self, @"Unterminated string"));
}

void GSONJsonReader_skipUnquotedValue(GSONJsonReader *self) {
  do {
    jint i = 0;
    for (; self->pos_ + i < self->limit_; i++) {
      switch (IOSCharArray_Get(nil_chk(self->buffer_), self->pos_ + i)) {
        case '/':
        case '\\':
        case ';':
        case '#':
        case '=':
        GSONJsonReader_checkLenient(self);
        case '{':
        case '}':
        case '[':
        case ']':
        case ':':
        case ',':
        case ' ':
        case 0x0009:
        case 0x000c:
        case 0x000d:
        case 0x000a:
        self->pos_ += i;
        return;
      }
    }
    self->pos_ += i;
  }
  while (GSONJsonReader_fillBufferWithInt_(self, 1));
}

void GSONJsonReader_pushWithInt_(GSONJsonReader *self, jint newTop) {
  if (self->stackSize_ == ((IOSIntArray *) nil_chk(self->stack_))->size_) {
    jint newLength = self->stackSize_ * 2;
    self->stack_ = JavaUtilArrays_copyOfWithIntArray_withInt_(self->stack_, newLength);
    self->pathIndices_ = JavaUtilArrays_copyOfWithIntArray_withInt_(self->pathIndices_, newLength);
    self->pathNames_ = JavaUtilArrays_copyOfWithNSObjectArray_withInt_(self->pathNames_, newLength);
  }
  *IOSIntArray_GetRef(nil_chk(self->stack_), self->stackSize_++) = newTop;
}

jboolean GSONJsonReader_fillBufferWithInt_(GSONJsonReader *self, jint minimum) {
  IOSCharArray *buffer = self->buffer_;
  self->lineStart_ -= self->pos_;
  if (self->limit_ != self->pos_) {
    self->limit_ -= self->pos_;
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(buffer, self->pos_, buffer, 0, self->limit_);
  }
  else {
    self->limit_ = 0;
  }
  self->pos_ = 0;
  jint total;
  while ((total = [((JavaIoReader *) nil_chk(self->in_)) readWithCharArray:buffer withInt:self->limit_ withInt:((IOSCharArray *) nil_chk(buffer))->size_ - self->limit_]) != -1) {
    self->limit_ += total;
    if (self->lineNumber_ == 0 && self->lineStart_ == 0 && self->limit_ > 0 && IOSCharArray_Get(buffer, 0) == 0xfeff) {
      self->pos_++;
      self->lineStart_++;
      minimum++;
    }
    if (self->limit_ >= minimum) {
      return true;
    }
  }
  return false;
}

jint GSONJsonReader_nextNonWhitespaceWithBoolean_(GSONJsonReader *self, jboolean throwOnEof) {
  IOSCharArray *buffer = self->buffer_;
  jint p = self->pos_;
  jint l = self->limit_;
  while (true) {
    if (p == l) {
      self->pos_ = p;
      if (!GSONJsonReader_fillBufferWithInt_(self, 1)) {
        break;
      }
      p = self->pos_;
      l = self->limit_;
    }
    jint c = IOSCharArray_Get(nil_chk(buffer), p++);
    if (c == 0x000a) {
      self->lineNumber_++;
      self->lineStart_ = p;
      continue;
    }
    else if (c == ' ' || c == 0x000d || c == 0x0009) {
      continue;
    }
    if (c == '/') {
      self->pos_ = p;
      if (p == l) {
        self->pos_--;
        jboolean charsLoaded = GSONJsonReader_fillBufferWithInt_(self, 2);
        self->pos_++;
        if (!charsLoaded) {
          return c;
        }
      }
      GSONJsonReader_checkLenient(self);
      jchar peek = IOSCharArray_Get(buffer, self->pos_);
      switch (peek) {
        case '*':
        self->pos_++;
        if (!GSONJsonReader_skipToWithNSString_(self, @"*/")) {
          @throw nil_chk(GSONJsonReader_syntaxErrorWithNSString_(self, @"Unterminated comment"));
        }
        p = self->pos_ + 2;
        l = self->limit_;
        continue;
        case '/':
        self->pos_++;
        GSONJsonReader_skipToEndOfLine(self);
        p = self->pos_;
        l = self->limit_;
        continue;
        default:
        return c;
      }
    }
    else if (c == '#') {
      self->pos_ = p;
      GSONJsonReader_checkLenient(self);
      GSONJsonReader_skipToEndOfLine(self);
      p = self->pos_;
      l = self->limit_;
    }
    else {
      self->pos_ = p;
      return c;
    }
  }
  if (throwOnEof) {
    @throw new_JavaIoEOFException_initWithNSString_(JreStrcat("$$", @"End of input", [self locationString]));
  }
  else {
    return -1;
  }
}

void GSONJsonReader_checkLenient(GSONJsonReader *self) {
  if (!self->lenient_) {
    @throw nil_chk(GSONJsonReader_syntaxErrorWithNSString_(self, @"Use JsonReader.setLenient(true) to accept malformed JSON"));
  }
}

void GSONJsonReader_skipToEndOfLine(GSONJsonReader *self) {
  while (self->pos_ < self->limit_ || GSONJsonReader_fillBufferWithInt_(self, 1)) {
    jchar c = IOSCharArray_Get(nil_chk(self->buffer_), self->pos_++);
    if (c == 0x000a) {
      self->lineNumber_++;
      self->lineStart_ = self->pos_;
      break;
    }
    else if (c == 0x000d) {
      break;
    }
  }
}

jboolean GSONJsonReader_skipToWithNSString_(GSONJsonReader *self, NSString *toFind) {
  jint length = [((NSString *) nil_chk(toFind)) java_length];
  for (; self->pos_ + length <= self->limit_ || GSONJsonReader_fillBufferWithInt_(self, length); self->pos_++) {
    {
      if (IOSCharArray_Get(nil_chk(self->buffer_), self->pos_) == 0x000a) {
        self->lineNumber_++;
        self->lineStart_ = self->pos_ + 1;
        continue;
      }
      for (jint c = 0; c < length; c++) {
        if (IOSCharArray_Get(self->buffer_, self->pos_ + c) != [toFind charAtWithInt:c]) {
          goto continue_outer;
        }
      }
      return true;
    }
    continue_outer: ;
  }
  return false;
}

jchar GSONJsonReader_readEscapeCharacter(GSONJsonReader *self) {
  if (self->pos_ == self->limit_ && !GSONJsonReader_fillBufferWithInt_(self, 1)) {
    @throw nil_chk(GSONJsonReader_syntaxErrorWithNSString_(self, @"Unterminated escape sequence"));
  }
  jchar escaped = IOSCharArray_Get(nil_chk(self->buffer_), self->pos_++);
  {
    jchar result;
    switch (escaped) {
      case 'u':
      if (self->pos_ + 4 > self->limit_ && !GSONJsonReader_fillBufferWithInt_(self, 4)) {
        @throw nil_chk(GSONJsonReader_syntaxErrorWithNSString_(self, @"Unterminated escape sequence"));
      }
      result = 0;
      for (jint i = self->pos_, end = i + 4; i < end; i++) {
        jchar c = IOSCharArray_Get(self->buffer_, i);
        JreLShiftAssignChar(&result, 4);
        if (c >= '0' && c <= '9') {
          result += (c - '0');
        }
        else if (c >= 'a' && c <= 'f') {
          result += (c - 'a' + 10);
        }
        else if (c >= 'A' && c <= 'F') {
          result += (c - 'A' + 10);
        }
        else {
          @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$$", @"\\u", [NSString java_stringWithCharacters:self->buffer_ offset:self->pos_ length:4]));
        }
      }
      self->pos_ += 4;
      return result;
      case 't':
      return 0x0009;
      case 'b':
      return 0x0008;
      case 'n':
      return 0x000a;
      case 'r':
      return 0x000d;
      case 'f':
      return 0x000c;
      case 0x000a:
      self->lineNumber_++;
      self->lineStart_ = self->pos_;
      case '\'':
      case '"':
      case '\\':
      case '/':
      return escaped;
      default:
      @throw nil_chk(GSONJsonReader_syntaxErrorWithNSString_(self, @"Invalid escape sequence"));
    }
  }
}

JavaIoIOException *GSONJsonReader_syntaxErrorWithNSString_(GSONJsonReader *self, NSString *message) {
  @throw new_GSONMalformedJsonException_initWithNSString_(JreStrcat("$$", message, [self locationString]));
}

void GSONJsonReader_consumeNonExecutePrefix(GSONJsonReader *self) {
  GSONJsonReader_nextNonWhitespaceWithBoolean_(self, true);
  self->pos_--;
  if (self->pos_ + ((IOSCharArray *) nil_chk(GSONJsonReader_NON_EXECUTE_PREFIX))->size_ > self->limit_ && !GSONJsonReader_fillBufferWithInt_(self, GSONJsonReader_NON_EXECUTE_PREFIX->size_)) {
    return;
  }
  for (jint i = 0; i < GSONJsonReader_NON_EXECUTE_PREFIX->size_; i++) {
    if (IOSCharArray_Get(nil_chk(self->buffer_), self->pos_ + i) != IOSCharArray_Get(GSONJsonReader_NON_EXECUTE_PREFIX, i)) {
      return;
    }
  }
  self->pos_ += GSONJsonReader_NON_EXECUTE_PREFIX->size_;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GSONJsonReader)

@implementation GSONJsonReader_1

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  GSONJsonReader_1_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)promoteNameToValueWithGSONJsonReader:(GSONJsonReader *)reader {
  if ([reader isKindOfClass:[GSONJsonTreeReader class]]) {
    [((GSONJsonTreeReader *) nil_chk(((GSONJsonTreeReader *) cast_chk(reader, [GSONJsonTreeReader class])))) promoteNameToValue];
    return;
  }
  jint p = ((GSONJsonReader *) nil_chk(reader))->peeked_;
  if (p == GSONJsonReader_PEEKED_NONE) {
    p = [reader doPeek];
  }
  if (p == GSONJsonReader_PEEKED_DOUBLE_QUOTED_NAME) {
    reader->peeked_ = GSONJsonReader_PEEKED_DOUBLE_QUOTED;
  }
  else if (p == GSONJsonReader_PEEKED_SINGLE_QUOTED_NAME) {
    reader->peeked_ = GSONJsonReader_PEEKED_SINGLE_QUOTED;
  }
  else if (p == GSONJsonReader_PEEKED_UNQUOTED_NAME) {
    reader->peeked_ = GSONJsonReader_PEEKED_UNQUOTED;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a name but was ", [reader peek], [reader locationString]));
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, 2, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(promoteNameToValueWithGSONJsonReader:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "promoteNameToValue", "LGSONJsonReader;", "LJavaIoIOException;" };
  static const J2ObjcClassInfo _GSONJsonReader_1 = { "", "com.google.gson.stream", ptrTable, methods, NULL, 7, 0x8018, 2, 0, 1, -1, -1, -1, -1 };
  return &_GSONJsonReader_1;
}

@end

void GSONJsonReader_1_init(GSONJsonReader_1 *self) {
  GSONJsonReaderInternalAccess_init(self);
}

GSONJsonReader_1 *new_GSONJsonReader_1_init() {
  J2OBJC_NEW_IMPL(GSONJsonReader_1, init)
}

GSONJsonReader_1 *create_GSONJsonReader_1_init() {
  J2OBJC_CREATE_IMPL(GSONJsonReader_1, init)
}
