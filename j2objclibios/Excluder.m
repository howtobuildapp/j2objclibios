//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/zhangwen/Documents/zwdir/sync/workspace/howtobuildapp/j2objclibios/javasrc/com/google/gson/internal/Excluder.java
//

#include "Excluder.h"
#include "ExclusionStrategy.h"
#include "Expose.h"
#include "FieldAttributes.h"
#include "Gson.h"
#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "JsonReader.h"
#include "JsonWriter.h"
#include "Since.h"
#include "TypeAdapter.h"
#include "TypeToken.h"
#include "Until.h"
#include "java/lang/AssertionError.h"
#include "java/lang/CloneNotSupportedException.h"
#include "java/lang/Enum.h"
#include "java/lang/reflect/Field.h"
#include "java/lang/reflect/Modifier.h"
#include "java/util/ArrayList.h"
#include "java/util/Collections.h"
#include "java/util/List.h"

@interface GSONExcluder () {
 @public
  jdouble version__;
  jint modifiers_;
  jboolean serializeInnerClasses_;
  jboolean requireExpose_;
  id<JavaUtilList> serializationStrategies_;
  id<JavaUtilList> deserializationStrategies_;
}

- (jboolean)excludeClassChecksWithIOSClass:(IOSClass *)clazz;

- (jboolean)excludeClassInStrategyWithIOSClass:(IOSClass *)clazz
                                   withBoolean:(jboolean)serialize;

- (jboolean)isAnonymousOrLocalWithIOSClass:(IOSClass *)clazz;

- (jboolean)isInnerClassWithIOSClass:(IOSClass *)clazz;

- (jboolean)isStaticWithIOSClass:(IOSClass *)clazz;

- (jboolean)isValidVersionWithGSONSince:(id<GSONSince>)since
                          withGSONUntil:(id<GSONUntil>)until;

- (jboolean)isValidSinceWithGSONSince:(id<GSONSince>)annotation;

- (jboolean)isValidUntilWithGSONUntil:(id<GSONUntil>)annotation;

@end

J2OBJC_FIELD_SETTER(GSONExcluder, serializationStrategies_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(GSONExcluder, deserializationStrategies_, id<JavaUtilList>)

inline jdouble GSONExcluder_get_IGNORE_VERSIONS();
#define GSONExcluder_IGNORE_VERSIONS -1.0
J2OBJC_STATIC_FIELD_CONSTANT(GSONExcluder, IGNORE_VERSIONS, jdouble)

__attribute__((unused)) static jboolean GSONExcluder_excludeClassChecksWithIOSClass_(GSONExcluder *self, IOSClass *clazz);

__attribute__((unused)) static jboolean GSONExcluder_excludeClassInStrategyWithIOSClass_withBoolean_(GSONExcluder *self, IOSClass *clazz, jboolean serialize);

__attribute__((unused)) static jboolean GSONExcluder_isAnonymousOrLocalWithIOSClass_(GSONExcluder *self, IOSClass *clazz);

__attribute__((unused)) static jboolean GSONExcluder_isInnerClassWithIOSClass_(GSONExcluder *self, IOSClass *clazz);

__attribute__((unused)) static jboolean GSONExcluder_isStaticWithIOSClass_(GSONExcluder *self, IOSClass *clazz);

__attribute__((unused)) static jboolean GSONExcluder_isValidVersionWithGSONSince_withGSONUntil_(GSONExcluder *self, id<GSONSince> since, id<GSONUntil> until);

__attribute__((unused)) static jboolean GSONExcluder_isValidSinceWithGSONSince_(GSONExcluder *self, id<GSONSince> annotation);

__attribute__((unused)) static jboolean GSONExcluder_isValidUntilWithGSONUntil_(GSONExcluder *self, id<GSONUntil> annotation);

@interface GSONExcluder_1 : GSONTypeAdapter {
 @public
  GSONExcluder *this$0_;
  jboolean val$skipDeserialize_;
  jboolean val$skipSerialize_;
  GSONGson *val$gson_;
  GSONTypeToken *val$type_;
  /*!
   @brief The delegate is lazily created because it may not be needed, and creating it may fail.
   */
  GSONTypeAdapter *delegate_;
}

- (instancetype)initWithGSONExcluder:(GSONExcluder *)outer$
                         withBoolean:(jboolean)capture$0
                         withBoolean:(jboolean)capture$1
                        withGSONGson:(GSONGson *)capture$2
                   withGSONTypeToken:(GSONTypeToken *)capture$3;

- (id)readWithGSONJsonReader:(GSONJsonReader *)inArg;

- (void)writeWithGSONJsonWriter:(GSONJsonWriter *)outArg
                         withId:(id)value;

- (GSONTypeAdapter *)delegate;

@end

J2OBJC_EMPTY_STATIC_INIT(GSONExcluder_1)

J2OBJC_FIELD_SETTER(GSONExcluder_1, delegate_, GSONTypeAdapter *)

__attribute__((unused)) static void GSONExcluder_1_initWithGSONExcluder_withBoolean_withBoolean_withGSONGson_withGSONTypeToken_(GSONExcluder_1 *self, GSONExcluder *outer$, jboolean capture$0, jboolean capture$1, GSONGson *capture$2, GSONTypeToken *capture$3);

__attribute__((unused)) static GSONExcluder_1 *new_GSONExcluder_1_initWithGSONExcluder_withBoolean_withBoolean_withGSONGson_withGSONTypeToken_(GSONExcluder *outer$, jboolean capture$0, jboolean capture$1, GSONGson *capture$2, GSONTypeToken *capture$3) NS_RETURNS_RETAINED;

__attribute__((unused)) static GSONExcluder_1 *create_GSONExcluder_1_initWithGSONExcluder_withBoolean_withBoolean_withGSONGson_withGSONTypeToken_(GSONExcluder *outer$, jboolean capture$0, jboolean capture$1, GSONGson *capture$2, GSONTypeToken *capture$3);

__attribute__((unused)) static GSONTypeAdapter *GSONExcluder_1_delegate(GSONExcluder_1 *self);

J2OBJC_INITIALIZED_DEFN(GSONExcluder)

GSONExcluder *GSONExcluder_DEFAULT;

@implementation GSONExcluder

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  GSONExcluder_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (GSONExcluder *)java_clone {
  @try {
    return (GSONExcluder *) cast_chk([super java_clone], [GSONExcluder class]);
  }
  @catch (JavaLangCloneNotSupportedException *e) {
    @throw new_JavaLangAssertionError_initWithId_(e);
  }
}

- (GSONExcluder *)withVersionWithDouble:(jdouble)ignoreVersionsAfter {
  GSONExcluder *result = [self java_clone];
  ((GSONExcluder *) nil_chk(result))->version__ = ignoreVersionsAfter;
  return result;
}

- (GSONExcluder *)withModifiersWithIntArray:(IOSIntArray *)modifiers {
  GSONExcluder *result = [self java_clone];
  ((GSONExcluder *) nil_chk(result))->modifiers_ = 0;
  {
    IOSIntArray *a__ = modifiers;
    jint const *b__ = ((IOSIntArray *) nil_chk(a__))->buffer_;
    jint const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      jint modifier = *b__++;
      result->modifiers_ |= modifier;
    }
  }
  return result;
}

- (GSONExcluder *)disableInnerClassSerialization {
  GSONExcluder *result = [self java_clone];
  ((GSONExcluder *) nil_chk(result))->serializeInnerClasses_ = false;
  return result;
}

- (GSONExcluder *)excludeFieldsWithoutExposeAnnotation {
  GSONExcluder *result = [self java_clone];
  ((GSONExcluder *) nil_chk(result))->requireExpose_ = true;
  return result;
}

- (GSONExcluder *)withExclusionStrategyWithGSONExclusionStrategy:(id<GSONExclusionStrategy>)exclusionStrategy
                                                     withBoolean:(jboolean)serialization
                                                     withBoolean:(jboolean)deserialization {
  GSONExcluder *result = [self java_clone];
  if (serialization) {
    ((GSONExcluder *) nil_chk(result))->serializationStrategies_ = new_JavaUtilArrayList_initWithJavaUtilCollection_(serializationStrategies_);
    [result->serializationStrategies_ addWithId:exclusionStrategy];
  }
  if (deserialization) {
    ((GSONExcluder *) nil_chk(result))->deserializationStrategies_ = new_JavaUtilArrayList_initWithJavaUtilCollection_(deserializationStrategies_);
    [result->deserializationStrategies_ addWithId:exclusionStrategy];
  }
  return result;
}

- (GSONTypeAdapter *)createWithGSONGson:(GSONGson *)gson
                      withGSONTypeToken:(GSONTypeToken *)type {
  IOSClass *rawType = [((GSONTypeToken *) nil_chk(type)) getRawType];
  jboolean excludeClass = GSONExcluder_excludeClassChecksWithIOSClass_(self, rawType);
  jboolean skipSerialize = excludeClass || GSONExcluder_excludeClassInStrategyWithIOSClass_withBoolean_(self, rawType, true);
  jboolean skipDeserialize = excludeClass || GSONExcluder_excludeClassInStrategyWithIOSClass_withBoolean_(self, rawType, false);
  if (!skipSerialize && !skipDeserialize) {
    return nil;
  }
  return new_GSONExcluder_1_initWithGSONExcluder_withBoolean_withBoolean_withGSONGson_withGSONTypeToken_(self, skipDeserialize, skipSerialize, gson, type);
}

- (jboolean)excludeFieldWithJavaLangReflectField:(JavaLangReflectField *)field
                                     withBoolean:(jboolean)serialize {
  if ((modifiers_ & [((JavaLangReflectField *) nil_chk(field)) getModifiers]) != 0) {
    return true;
  }
  if (version__ != GSONExcluder_IGNORE_VERSIONS && !GSONExcluder_isValidVersionWithGSONSince_withGSONUntil_(self, ((id<GSONSince>) [field getAnnotationWithIOSClass:GSONSince_class_()]), ((id<GSONUntil>) [field getAnnotationWithIOSClass:GSONUntil_class_()]))) {
    return true;
  }
  if ([field isSynthetic]) {
    return true;
  }
  if (requireExpose_) {
    id<GSONExpose> annotation = ((id<GSONExpose>) [field getAnnotationWithIOSClass:GSONExpose_class_()]);
    if (annotation == nil || (serialize ? ![annotation serialize] : ![annotation deserialize])) {
      return true;
    }
  }
  if (!serializeInnerClasses_ && GSONExcluder_isInnerClassWithIOSClass_(self, [field getType])) {
    return true;
  }
  if (GSONExcluder_isAnonymousOrLocalWithIOSClass_(self, [field getType])) {
    return true;
  }
  id<JavaUtilList> list = serialize ? serializationStrategies_ : deserializationStrategies_;
  if (![list isEmpty]) {
    GSONFieldAttributes *fieldAttributes = new_GSONFieldAttributes_initWithJavaLangReflectField_(field);
    for (id<GSONExclusionStrategy> __strong exclusionStrategy in list) {
      if ([((id<GSONExclusionStrategy>) nil_chk(exclusionStrategy)) shouldSkipFieldWithGSONFieldAttributes:fieldAttributes]) {
        return true;
      }
    }
  }
  return false;
}

- (jboolean)excludeClassChecksWithIOSClass:(IOSClass *)clazz {
  return GSONExcluder_excludeClassChecksWithIOSClass_(self, clazz);
}

- (jboolean)excludeClassWithIOSClass:(IOSClass *)clazz
                         withBoolean:(jboolean)serialize {
  return GSONExcluder_excludeClassChecksWithIOSClass_(self, clazz) || GSONExcluder_excludeClassInStrategyWithIOSClass_withBoolean_(self, clazz, serialize);
}

- (jboolean)excludeClassInStrategyWithIOSClass:(IOSClass *)clazz
                                   withBoolean:(jboolean)serialize {
  return GSONExcluder_excludeClassInStrategyWithIOSClass_withBoolean_(self, clazz, serialize);
}

- (jboolean)isAnonymousOrLocalWithIOSClass:(IOSClass *)clazz {
  return GSONExcluder_isAnonymousOrLocalWithIOSClass_(self, clazz);
}

- (jboolean)isInnerClassWithIOSClass:(IOSClass *)clazz {
  return GSONExcluder_isInnerClassWithIOSClass_(self, clazz);
}

- (jboolean)isStaticWithIOSClass:(IOSClass *)clazz {
  return GSONExcluder_isStaticWithIOSClass_(self, clazz);
}

- (jboolean)isValidVersionWithGSONSince:(id<GSONSince>)since
                          withGSONUntil:(id<GSONUntil>)until {
  return GSONExcluder_isValidVersionWithGSONSince_withGSONUntil_(self, since, until);
}

- (jboolean)isValidSinceWithGSONSince:(id<GSONSince>)annotation {
  return GSONExcluder_isValidSinceWithGSONSince_(self, annotation);
}

- (jboolean)isValidUntilWithGSONUntil:(id<GSONUntil>)annotation {
  return GSONExcluder_isValidUntilWithGSONUntil_(self, annotation);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LGSONExcluder;", 0x4, 0, -1, -1, -1, -1, -1 },
    { NULL, "LGSONExcluder;", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "LGSONExcluder;", 0x81, 3, 4, -1, -1, -1, -1 },
    { NULL, "LGSONExcluder;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LGSONExcluder;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LGSONExcluder;", 0x1, 5, 6, -1, -1, -1, -1 },
    { NULL, "LGSONTypeAdapter;", 0x1, 7, 8, -1, 9, -1, -1 },
    { NULL, "Z", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 12, 13, -1, 14, -1, -1 },
    { NULL, "Z", 0x1, 15, 16, -1, 17, -1, -1 },
    { NULL, "Z", 0x2, 18, 16, -1, 17, -1, -1 },
    { NULL, "Z", 0x2, 19, 13, -1, 14, -1, -1 },
    { NULL, "Z", 0x2, 20, 13, -1, 14, -1, -1 },
    { NULL, "Z", 0x2, 21, 13, -1, 14, -1, -1 },
    { NULL, "Z", 0x2, 22, 23, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 24, 25, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 26, 27, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(java_clone);
  methods[2].selector = @selector(withVersionWithDouble:);
  methods[3].selector = @selector(withModifiersWithIntArray:);
  methods[4].selector = @selector(disableInnerClassSerialization);
  methods[5].selector = @selector(excludeFieldsWithoutExposeAnnotation);
  methods[6].selector = @selector(withExclusionStrategyWithGSONExclusionStrategy:withBoolean:withBoolean:);
  methods[7].selector = @selector(createWithGSONGson:withGSONTypeToken:);
  methods[8].selector = @selector(excludeFieldWithJavaLangReflectField:withBoolean:);
  methods[9].selector = @selector(excludeClassChecksWithIOSClass:);
  methods[10].selector = @selector(excludeClassWithIOSClass:withBoolean:);
  methods[11].selector = @selector(excludeClassInStrategyWithIOSClass:withBoolean:);
  methods[12].selector = @selector(isAnonymousOrLocalWithIOSClass:);
  methods[13].selector = @selector(isInnerClassWithIOSClass:);
  methods[14].selector = @selector(isStaticWithIOSClass:);
  methods[15].selector = @selector(isValidVersionWithGSONSince:withGSONUntil:);
  methods[16].selector = @selector(isValidSinceWithGSONSince:);
  methods[17].selector = @selector(isValidUntilWithGSONUntil:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "IGNORE_VERSIONS", "D", .constantValue.asDouble = GSONExcluder_IGNORE_VERSIONS, 0x1a, -1, -1, -1, -1 },
    { "DEFAULT", "LGSONExcluder;", .constantValue.asLong = 0, 0x19, -1, 28, -1, -1 },
    { "version__", "D", .constantValue.asLong = 0, 0x2, 29, -1, -1, -1 },
    { "modifiers_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "serializeInnerClasses_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "requireExpose_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "serializationStrategies_", "LJavaUtilList;", .constantValue.asLong = 0, 0x2, -1, -1, 30, -1 },
    { "deserializationStrategies_", "LJavaUtilList;", .constantValue.asLong = 0, 0x2, -1, -1, 30, -1 },
  };
  static const void *ptrTable[] = { "clone", "withVersion", "D", "withModifiers", "[I", "withExclusionStrategy", "LGSONExclusionStrategy;ZZ", "create", "LGSONGson;LGSONTypeToken;", "<T:Ljava/lang/Object;>(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken<TT;>;)Lcom/google/gson/TypeAdapter<TT;>;", "excludeField", "LJavaLangReflectField;Z", "excludeClassChecks", "LIOSClass;", "(Ljava/lang/Class<*>;)Z", "excludeClass", "LIOSClass;Z", "(Ljava/lang/Class<*>;Z)Z", "excludeClassInStrategy", "isAnonymousOrLocal", "isInnerClass", "isStatic", "isValidVersion", "LGSONSince;LGSONUntil;", "isValidSince", "LGSONSince;", "isValidUntil", "LGSONUntil;", &GSONExcluder_DEFAULT, "version", "Ljava/util/List<Lcom/google/gson/ExclusionStrategy;>;" };
  static const J2ObjcClassInfo _GSONExcluder = { "Excluder", "com.google.gson.internal", ptrTable, methods, fields, 7, 0x11, 18, 8, -1, -1, -1, -1, -1 };
  return &_GSONExcluder;
}

- (id)copyWithZone:(NSZone *)zone {
  return [self java_clone];
}

+ (void)initialize {
  if (self == [GSONExcluder class]) {
    GSONExcluder_DEFAULT = new_GSONExcluder_init();
    J2OBJC_SET_INITIALIZED(GSONExcluder)
  }
}

@end

void GSONExcluder_init(GSONExcluder *self) {
  NSObject_init(self);
  self->version__ = GSONExcluder_IGNORE_VERSIONS;
  self->modifiers_ = JavaLangReflectModifier_TRANSIENT | JavaLangReflectModifier_STATIC;
  self->serializeInnerClasses_ = true;
  self->serializationStrategies_ = JavaUtilCollections_emptyList();
  self->deserializationStrategies_ = JavaUtilCollections_emptyList();
}

GSONExcluder *new_GSONExcluder_init() {
  J2OBJC_NEW_IMPL(GSONExcluder, init)
}

GSONExcluder *create_GSONExcluder_init() {
  J2OBJC_CREATE_IMPL(GSONExcluder, init)
}

jboolean GSONExcluder_excludeClassChecksWithIOSClass_(GSONExcluder *self, IOSClass *clazz) {
  if (self->version__ != GSONExcluder_IGNORE_VERSIONS && !GSONExcluder_isValidVersionWithGSONSince_withGSONUntil_(self, ((id<GSONSince>) [((IOSClass *) nil_chk(clazz)) getAnnotationWithIOSClass:GSONSince_class_()]), ((id<GSONUntil>) [clazz getAnnotationWithIOSClass:GSONUntil_class_()]))) {
    return true;
  }
  if (!self->serializeInnerClasses_ && GSONExcluder_isInnerClassWithIOSClass_(self, clazz)) {
    return true;
  }
  if (GSONExcluder_isAnonymousOrLocalWithIOSClass_(self, clazz)) {
    return true;
  }
  return false;
}

jboolean GSONExcluder_excludeClassInStrategyWithIOSClass_withBoolean_(GSONExcluder *self, IOSClass *clazz, jboolean serialize) {
  id<JavaUtilList> list = serialize ? self->serializationStrategies_ : self->deserializationStrategies_;
  for (id<GSONExclusionStrategy> __strong exclusionStrategy in list) {
    if ([((id<GSONExclusionStrategy>) nil_chk(exclusionStrategy)) shouldSkipClassWithIOSClass:clazz]) {
      return true;
    }
  }
  return false;
}

jboolean GSONExcluder_isAnonymousOrLocalWithIOSClass_(GSONExcluder *self, IOSClass *clazz) {
  return ![JavaLangEnum_class_() isAssignableFrom:clazz] && ([((IOSClass *) nil_chk(clazz)) isAnonymousClass] || [clazz isLocalClass]);
}

jboolean GSONExcluder_isInnerClassWithIOSClass_(GSONExcluder *self, IOSClass *clazz) {
  return [((IOSClass *) nil_chk(clazz)) isMemberClass] && !GSONExcluder_isStaticWithIOSClass_(self, clazz);
}

jboolean GSONExcluder_isStaticWithIOSClass_(GSONExcluder *self, IOSClass *clazz) {
  return ([((IOSClass *) nil_chk(clazz)) getModifiers] & JavaLangReflectModifier_STATIC) != 0;
}

jboolean GSONExcluder_isValidVersionWithGSONSince_withGSONUntil_(GSONExcluder *self, id<GSONSince> since, id<GSONUntil> until) {
  return GSONExcluder_isValidSinceWithGSONSince_(self, since) && GSONExcluder_isValidUntilWithGSONUntil_(self, until);
}

jboolean GSONExcluder_isValidSinceWithGSONSince_(GSONExcluder *self, id<GSONSince> annotation) {
  if (annotation != nil) {
    jdouble annotationVersion = [annotation value];
    if (annotationVersion > self->version__) {
      return false;
    }
  }
  return true;
}

jboolean GSONExcluder_isValidUntilWithGSONUntil_(GSONExcluder *self, id<GSONUntil> annotation) {
  if (annotation != nil) {
    jdouble annotationVersion = [annotation value];
    if (annotationVersion <= self->version__) {
      return false;
    }
  }
  return true;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GSONExcluder)

@implementation GSONExcluder_1

- (instancetype)initWithGSONExcluder:(GSONExcluder *)outer$
                         withBoolean:(jboolean)capture$0
                         withBoolean:(jboolean)capture$1
                        withGSONGson:(GSONGson *)capture$2
                   withGSONTypeToken:(GSONTypeToken *)capture$3 {
  GSONExcluder_1_initWithGSONExcluder_withBoolean_withBoolean_withGSONGson_withGSONTypeToken_(self, outer$, capture$0, capture$1, capture$2, capture$3);
  return self;
}

- (id)readWithGSONJsonReader:(GSONJsonReader *)inArg {
  if (val$skipDeserialize_) {
    [((GSONJsonReader *) nil_chk(inArg)) skipValue];
    return nil;
  }
  return [((GSONTypeAdapter *) nil_chk(GSONExcluder_1_delegate(self))) readWithGSONJsonReader:inArg];
}

- (void)writeWithGSONJsonWriter:(GSONJsonWriter *)outArg
                         withId:(id)value {
  if (val$skipSerialize_) {
    (void) [((GSONJsonWriter *) nil_chk(outArg)) nullValue];
    return;
  }
  [((GSONTypeAdapter *) nil_chk(GSONExcluder_1_delegate(self))) writeWithGSONJsonWriter:outArg withId:value];
}

- (GSONTypeAdapter *)delegate {
  return GSONExcluder_1_delegate(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, 0, 1, 2, 3, -1, -1 },
    { NULL, "V", 0x1, 4, 5, 2, 6, -1, -1 },
    { NULL, "LGSONTypeAdapter;", 0x2, -1, -1, -1, 7, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithGSONExcluder:withBoolean:withBoolean:withGSONGson:withGSONTypeToken:);
  methods[1].selector = @selector(readWithGSONJsonReader:);
  methods[2].selector = @selector(writeWithGSONJsonWriter:withId:);
  methods[3].selector = @selector(delegate);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LGSONExcluder;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "val$skipDeserialize_", "Z", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "val$skipSerialize_", "Z", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "val$gson_", "LGSONGson;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "val$type_", "LGSONTypeToken;", .constantValue.asLong = 0, 0x1012, -1, -1, 8, -1 },
    { "delegate_", "LGSONTypeAdapter;", .constantValue.asLong = 0, 0x2, -1, -1, 9, -1 },
  };
  static const void *ptrTable[] = { "read", "LGSONJsonReader;", "LJavaIoIOException;", "(Lcom/google/gson/stream/JsonReader;)TT;", "write", "LGSONJsonWriter;LNSObject;", "(Lcom/google/gson/stream/JsonWriter;TT;)V", "()Lcom/google/gson/TypeAdapter<TT;>;", "Lcom/google/gson/reflect/TypeToken<TT;>;", "Lcom/google/gson/TypeAdapter<TT;>;", "LGSONExcluder;", "createWithGSONGson:withGSONTypeToken:" };
  static const J2ObjcClassInfo _GSONExcluder_1 = { "", "com.google.gson.internal", ptrTable, methods, fields, 7, 0x8018, 4, 6, 10, -1, 11, 9, -1 };
  return &_GSONExcluder_1;
}

@end

void GSONExcluder_1_initWithGSONExcluder_withBoolean_withBoolean_withGSONGson_withGSONTypeToken_(GSONExcluder_1 *self, GSONExcluder *outer$, jboolean capture$0, jboolean capture$1, GSONGson *capture$2, GSONTypeToken *capture$3) {
  self->this$0_ = outer$;
  self->val$skipDeserialize_ = capture$0;
  self->val$skipSerialize_ = capture$1;
  self->val$gson_ = capture$2;
  self->val$type_ = capture$3;
  GSONTypeAdapter_init(self);
}

GSONExcluder_1 *new_GSONExcluder_1_initWithGSONExcluder_withBoolean_withBoolean_withGSONGson_withGSONTypeToken_(GSONExcluder *outer$, jboolean capture$0, jboolean capture$1, GSONGson *capture$2, GSONTypeToken *capture$3) {
  J2OBJC_NEW_IMPL(GSONExcluder_1, initWithGSONExcluder_withBoolean_withBoolean_withGSONGson_withGSONTypeToken_, outer$, capture$0, capture$1, capture$2, capture$3)
}

GSONExcluder_1 *create_GSONExcluder_1_initWithGSONExcluder_withBoolean_withBoolean_withGSONGson_withGSONTypeToken_(GSONExcluder *outer$, jboolean capture$0, jboolean capture$1, GSONGson *capture$2, GSONTypeToken *capture$3) {
  J2OBJC_CREATE_IMPL(GSONExcluder_1, initWithGSONExcluder_withBoolean_withBoolean_withGSONGson_withGSONTypeToken_, outer$, capture$0, capture$1, capture$2, capture$3)
}

GSONTypeAdapter *GSONExcluder_1_delegate(GSONExcluder_1 *self) {
  GSONTypeAdapter *d = self->delegate_;
  return d != nil ? d : (self->delegate_ = [((GSONGson *) nil_chk(self->val$gson_)) getDelegateAdapterWithGSONTypeAdapterFactory:self->this$0_ withGSONTypeToken:self->val$type_]);
}
